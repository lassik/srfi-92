(define-syntax alambda
  (syntax-rules (cond)
    ((alambda (g . e) b d ...)
     (%alambda "chk" () (() () () ()) () () () (() ()) () (g . e) b d ...))
    ((alambda (cond clause cl ...))
     (lambda z
       (let ((len (length z)))
         (check-cond z len () () clause cl ...))))
    ((alambda e b d ...)
     (lambda e b d ...))))
(define-syntax %alambda
  (syntax-rules ()
    ;; "chk"
    ((%alambda "chk" () ((h ...) () () ()) (r ...) ()
               () (() ()) () ("required cat" . e) bd ...)
     (%alambda "rat" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ((%alambda "chk" () ((h ...) () () ()) (r ...) ()
               () (() ()) () ("required key" . e) bd ...)
     (%alambda "rey" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ((%alambda "chk" () ((h ...) () () ()) (r ...) ()
               () (() ()) () ("opt" . e) bd ...)
     (%alambda "opt" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ((%alambda "chk" () ((h ...) () () ()) (r ...) ()
               () (() ()) () ("cat" . e) bd ...)
     (%alambda "cat" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ((%alambda "chk" () ((h ...) () () ()) (r ...) ()
               () (() ()) () ("key" . e) bd ...)
     (%alambda "key" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ;; "rat"
    ((%alambda "rat" () ((h ...) (i in ...) () ()) (r ...) (rk ...)
               () (() ()) () ("required key" . e) bd ...)
     (%alambda "rey" () ((h ...) (i in ...) () ()) (r ...) (rk ...)
               () (() ()) () e bd ...))
    ((%alambda "rat" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () ("opt" . e) bd ...)
     (%alambda "opt" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () e bd ...))
    ((%alambda "rat" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () ("cat" . e) bd ...)
     (%alambda "cat" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () e bd ...))
    ((%alambda "rat" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () ("key" . e) bd ...)
     (%alambda "key" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () e bd ...))
    ;; "rey"
    ((%alambda "rey" () ((h ...) () (j jn ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () ("required cat" . e) bd ...)
     (%alambda "rat" () ((h ...) () (j jn ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () e bd ...))
    ((%alambda "rey" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () ("opt" . e) bd ...)
     (%alambda "opt" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () e bd ...))
    ((%alambda "rey" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () ("cat" . e) bd ...)
     (%alambda "cat" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () e bd ...))
    ((%alambda "rey" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () ("key" . e) bd ...)
     (%alambda "key" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
               () (() ()) () e bd ...))
    ;; "opt"
    ((%alambda "opt" () hijk (r ...) (rk ...)
               (o on ...) (() ()) () ("cat" . e) bd ...)
     (%alambda "cat" () hijk (r ...) (rk ...)
               (o on ...) (() ()) () e bd ...))
    ((%alambda "opt" () hijk (r ...) (rk ...)
               (o on ...) (() ()) () ("key" . e) bd ...)
     (%alambda "key" () hijk (r ...) (rk ...)
               (o on ...) (() ()) () e bd ...))
    ;; "cat"
    ((%alambda "cat" () hijk (r ...) (rk ...)
               (o ...) ((c cn ...) ()) (ok ...) ("key" . e) bd ...)
     (%alambda "key" () hijk (r ...) (rk ...)
               (o ...) ((c cn ...) ()) (ok ...) e bd ...))
    ;; "key"
    ((%alambda "key" () hijk (r ...) (rk ...)
               (o ...) (() (k kn ...)) (ok ...) ("cat" . e) bd ...)
     (%alambda "cat" () hijk (r ...) (rk ...)
               (o ...) (() (k kn ...)) (ok ...) e bd ...))
    ;; key option
    ((%alambda check () ((h ...) (i ...) (j ...) (jk jkn ...)) (r ...)
               (rk ...) (o ...) ((c ...) (k ...)) (ok ...) (#t . e) bd ...)
     (%alambda check (#t) ((h ...) (i ...) (j ...) (jk jkn ...)) (r ...)
               (rk ...) (o ...) ((c ...) (k ...)) (ok ...) e bd ...))
    ((%alambda check () ((h ...) (i ...) (j ...) (jk jkn ...)) (r ...)
               (rk ...) (o ...) ((c ...) (k ...)) (ok ...) (#f . e) bd ...)
     (%alambda check (#f) ((h ...) (i ...) (j ...) (jk jkn ...)) (r ...)
               (rk ...) (o ...) ((c ...) (k ...)) (ok ...) e bd ...))
    ((%alambda check () hijk (r ...) (rk ...)
               (o ...) ((c ...) (k kn ...)) (ok ...) (#t . e) bd ...)
     (%alambda check (#t) hijk (r ...) (rk ...)
               (o ...) ((c ...) (k kn ...)) (ok ...) e bd ...))
    ((%alambda check () hijk (r ...) (rk ...)
               (o ...) ((c ...) (k kn ...)) (ok ...) (#f . e) bd ...)
     (%alambda check (#f) hijk (r ...) (rk ...)
               (o ...) ((c ...) (k kn ...)) (ok ...) e bd ...))
    ;; required fix arguments
    ((%alambda "chk" () ((h ...) () () ())
               (r ...) () () (() ()) () ((n t s ...) . e) bd ...)
     (%alambda "chk" () ((h ... hn) () () ())
               (r ... (n t s ...)) () () (() ()) () e bd ...))
    ((%alambda "chk" () ((h ...) () () ())
               (r ...) () () (() ()) () (n . e) bd ...)
     (%alambda "chk" () ((h ... hn) () () ())
               (r ... (n)) () () (() ()) () e bd ...))
    ;; required cat arguments
    ((%alambda "rat" () ((h ...) (i ...) (j ...) (jk ...))
               (r ...) (rk ...) () (() ()) () ((n t s ...) . e) bd ...)
     (%alambda "rat" () ((h ...) (i ... in) (j ...) (jk ...))
               (r ...) (rk ... ((n) t s ...)) () (() ()) () e bd ...))
    ((%alambda "rat" () ((h ...) (i ...) (j ...) (jk ...))
               (r ...) (rk ...) () (() ()) () (n . e) bd ...)
     (%alambda "rat" () ((h ...) (i ... in) (j ...) (jk ...))
               (r ...) (rk ... ((n))) () (() ()) () e bd ...))
    ;; required key arguments
    ((%alambda "rey" () ((h ...) (i ...) (j ...) (jk ...))
               (r ...) (rk ...) () (() ()) () (((n key) t ...) . e) bd ...)
     (%alambda "rey" () ((h ...) (i ...) (j ... jm jn) (jk ... key))
               (r ...) (rk ... ((n key) t ...)) () (() ()) () e bd ...))
    ((%alambda "rey" () ((h ...) (i ...) (j ...) (jk ...))
               (r ...) (rk ...) () (() ()) () ((n t s ...) . e) bd ...)
     (%alambda "rey" () ((h ...) (i ...) (j ... jm jn) (jk ... 'n))
               (r ...) (rk ... ((n 'n) t s ...)) () (() ()) () e bd ...))
    ((%alambda "rey" () ((h ...) (i ...) (j ...) (jk ...))
               (r ...) (rk ...) () (() ()) () (n . e) bd ...)
     (%alambda "rey" () ((h ...) (i ...) (j ... jm jn) (jk ... 'n))
               (r ...) (rk ... ((n 'n))) () (() ()) () e bd ...))
    ;; optional fix arguments
    ((%alambda "opt" () hijk (r ...) (rk ...)
               (o ...) (() ()) () ((n d t ...) . e) bd ...)
     (%alambda "opt" () hijk (r ...) (rk ...)
               (o ... (n d t ...)) (() ()) () e bd ...))
    ((%alambda "opt" () hijk (r ...) (rk ...)
               (o ...) (() ()) () (n . e) bd ...)
     (%alambda "opt" () hijk (r ...) (rk ...)
               (o ... (n #f)) (() ()) () e bd ...))
    ;; optional cat arguments
    ((%alambda "cat" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ...)) (ok ...) ((n d t ...) . e) bd ...)
     (%alambda "cat" () hijk (r ...) (rk ...) (o ...)
               ((c ... n) (k ...)) (ok ... ((n) d t ...)) e bd ...))
    ((%alambda "cat" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ...)) (ok ...) (n . e) bd ...)
     (%alambda "cat" () hijk (r ...) (rk ...) (o ...)
               ((c ... n) (k ...)) (ok ... ((n) #f)) e bd ...))
    ;; optional key arguments
    ((%alambda "key" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ...)) (ok ...) (((n key) d t ...) . e) bd ...)
     (%alambda "key" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ... key)) (ok ... ((n key) d t ...)) e bd ...))
    ((%alambda "key" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ...)) (ok ...) (((n key)) . e) bd ...)
     (%alambda "key" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ... key)) (ok ... ((n key) #f)) e bd ...))
    ((%alambda "key" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ...)) (ok ...) ((n d t ...) . e) bd ...)
     (%alambda "key" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ... 'n)) (ok ... ((n 'n) d t ...)) e bd ...))
    ((%alambda "key" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ...)) (ok ...) (n . e) bd ...)
     (%alambda "key" () hijk (r ...) (rk ...) (o ...)
               ((c ...) (k ... 'n)) (ok ... ((n 'n) #f)) e bd ...))
    ;; main
    ((%alambda check () hijk ((n) ...) () () (() ()) () e bd ...)
     (lambda (n ... . e) bd ...))
    ((%alambda check dft ((h ...) (i ...) (j ...) jk)
               ((n t ...) ...) (((rn rk ...) rt ...) ...)
               () (() ()) () () bd ...)
     (lambda (h ... i ... j ...)
       (let ((zz (list i ... j ...)))
         (let ((n (wow-opt n h t ...)) ...
               (rn (wow-req! zz dft jk (rn rk ...) rt ...)) ...)
           bd ...))))
    ((%alambda check dft ((h ...) (i ...) (j ...) jk)
               ((n t ...) ...) (((rn rk ...) rt ...) ...)
               () (() ()) () e bd ...)
     (lambda (h ... i ... j ... . te)
       (let ((zz (list i ... j ...)))
         (let ((n (wow-opt n h t ...)) ...
               (rn (wow-req! zz dft jk (rn rk ...) rt ...)) ...
               (e te))
           bd ...))))
    ((%alambda check dft ((h ...) () () ()) ((n) ...) ()
               (o ...) ((c ...) (k ...)) (ondt ...) e bd ...)
     (lambda (h ... . te)
       (check-opt te dft ((n h) ...) (o ...) (ondt ...)
                  e (k ...) bd ...)))
    ((%alambda check dft ((h ...) (i ...) (j ...) jk)
               ((n t ...) ...) (((rn rk ...) rt ...) ...)
               (o ...) ((c ...) (k ...)) (ondt ...) e bd ...)
     (lambda (h ... i ... j ... . te)
       (let ((zz (list i ... j ...)))
         (check-opt te dft
                    ((n (wow-opt n h t ...)) ...
                     (rn (wow-req! zz dft jk (rn rk ...) rt ...))
                     ...)
                    (o ...) (ondt ...) e (k ...) bd ...))))))

(define-syntax alambda*
  (syntax-rules (cond)
    ((alambda* (g . e) b d ...)
     (%alambda* "chk" () (() () () ()) () () () (() ()) () (g . e) b d ...))
    ((alambda* (cond clause cl ...))
     (lambda z
       (let ((len (length z)))
         (check-cond* z len () () clause cl ...))))
    ((alambda* e b d ...)
     (lambda e b d ...))))
(define-syntax %alambda*
  (syntax-rules ()
    ;; "chk"
    ((%alambda* "chk" () ((h ...) () () ()) (r ...) ()
                () (() ()) () ("required cat" . e) bd ...)
     (%alambda* "rat" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ((%alambda* "chk" () ((h ...) () () ()) (r ...) ()
                () (() ()) () ("required key" . e) bd ...)
     (%alambda* "rey" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ((%alambda* "chk" () ((h ...) () () ()) (r ...) ()
                () (() ()) () ("opt" . e) bd ...)
     (%alambda* "opt" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ((%alambda* "chk" () ((h ...) () () ()) (r ...) ()
                () (() ()) () ("cat" . e) bd ...)
     (%alambda* "cat" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ((%alambda* "chk" () ((h ...) () () ()) (r ...) ()
                () (() ()) () ("key" . e) bd ...)
     (%alambda* "key" () ((h ...) () () ()) (r ...) () () (() ()) () e bd ...))
    ;; "rat"
    ((%alambda* "rat" () ((h ...) (i in ...) () ()) (r ...) (rk ...)
                () (() ()) () ("required key" . e) bd ...)
     (%alambda* "rey" () ((h ...) (i in ...) () ()) (r ...) (rk ...)
                () (() ()) () e bd ...))
    ((%alambda* "rat" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () ("opt" . e) bd ...)
     (%alambda* "opt" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () e bd ...))
    ((%alambda* "rat" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () ("cat" . e) bd ...)
     (%alambda* "cat" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () e bd ...))
    ((%alambda* "rat" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () ("key" . e) bd ...)
     (%alambda* "key" () ((h ...) (i in ...) (j ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () e bd ...))
    ;; "rey"
    ((%alambda* "rey" () ((h ...) () (j jn ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () ("required cat" . e) bd ...)
     (%alambda* "rat" () ((h ...) () (j jn ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () e bd ...))
    ((%alambda* "rey" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () ("opt" . e) bd ...)
     (%alambda* "opt" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () e bd ...))
    ((%alambda* "rey" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () ("cat" . e) bd ...)
     (%alambda* "cat" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () e bd ...))
    ((%alambda* "rey" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () ("key" . e) bd ...)
     (%alambda* "key" () ((h ...) (i ...) (j jn ...) (jk ...)) (r ...) (rk ...)
                () (() ()) () e bd ...))
    ;; "opt"
    ((%alambda* "opt" () hijk (r ...) (rk ...)
                (o on ...) (() ()) () ("cat" . e) bd ...)
     (%alambda* "cat" () hijk (r ...) (rk ...)
                (o on ...) (() ()) () e bd ...))
    ((%alambda* "opt" () hijk (r ...) (rk ...)
                (o on ...) (() ()) () ("key" . e) bd ...)
     (%alambda* "key" () hijk (r ...) (rk ...)
                (o on ...) (() ()) () e bd ...))
    ;; "cat"
    ((%alambda* "cat" () hijk (r ...) (rk ...)
                (o ...) ((c cn ...) ()) (ok ...) ("key" . e) bd ...)
     (%alambda* "key" () hijk (r ...) (rk ...)
                (o ...) ((c cn ...) ()) (ok ...) e bd ...))
    ;; "key"
    ((%alambda* "key" () hijk (r ...) (rk ...)
                (o ...) (() (k kn ...)) (ok ...) ("cat" . e) bd ...)
     (%alambda* "cat" () hijk (r ...) (rk ...)
                (o ...) (() (k kn ...)) (ok ...) e bd ...))
    ;; key option
    ((%alambda* check () ((h ...) (i ...) (j ...) (jk jkn ...)) (r ...)
                (rk ...) (o ...) ((c ...) (k ...)) (ok ...) (#t . e) bd ...)
     (%alambda* check (#t) ((h ...) (i ...) (j ...) (jk jkn ...)) (r ...)
                (rk ...) (o ...) ((c ...) (k ...)) (ok ...) e bd ...))
    ((%alambda* check () ((h ...) (i ...) (j ...) (jk jkn ...)) (r ...)
                (rk ...) (o ...) ((c ...) (k ...)) (ok ...) (#f . e) bd ...)
     (%alambda* check (#f) ((h ...) (i ...) (j ...) (jk jkn ...)) (r ...)
                (rk ...) (o ...) ((c ...) (k ...)) (ok ...) e bd ...))
    ((%alambda* check () hijk (r ...) (rk ...)
                (o ...) ((c ...) (k kn ...)) (ok ...) (#t . e) bd ...)
     (%alambda* check (#t) hijk (r ...) (rk ...)
                (o ...) ((c ...) (k kn ...)) (ok ...) e bd ...))
    ((%alambda* check () hijk (r ...) (rk ...)
                (o ...) ((c ...) (k kn ...)) (ok ...) (#f . e) bd ...)
     (%alambda* check (#f) hijk (r ...) (rk ...)
                (o ...) ((c ...) (k kn ...)) (ok ...) e bd ...))
    ;; required fix arguments
    ((%alambda* "chk" () ((h ...) () () ())
                (r ...) () () (() ()) () ((n t s ...) . e) bd ...)
     (%alambda* "chk" () ((h ... hn) () () ())
                (r ... (n t s ...)) () () (() ()) () e bd ...))
    ((%alambda* "chk" () ((h ...) () () ())
                (r ...) () () (() ()) () (n . e) bd ...)
     (%alambda* "chk" () ((h ... hn) () () ())
                (r ... (n)) () () (() ()) () e bd ...))
    ;; required cat arguments
    ((%alambda* "rat" () ((h ...) (i ...) (j ...) (jk ...))
                (r ...) (rk ...) () (() ()) () ((n t s ...) . e) bd ...)
     (%alambda* "rat" () ((h ...) (i ... in) (j ...) (jk ...))
                (r ...) (rk ... ((n) t s ...)) () (() ()) () e bd ...))
    ((%alambda* "rat" () ((h ...) (i ...) (j ...) (jk ...))
                (r ...) (rk ...) () (() ()) () (n . e) bd ...)
     (%alambda* "rat" () ((h ...) (i ... in) (j ...) (jk ...))
                (r ...) (rk ... ((n))) () (() ()) () e bd ...))
    ;; required key arguments
    ((%alambda* "rey" () ((h ...) (i ...) (j ...) (jk ...))
                (r ...) (rk ...) () (() ()) () (((n key) t ...) . e) bd ...)
     (%alambda* "rey" () ((h ...) (i ...) (j ... jm jn) (jk ... key))
                (r ...) (rk ... ((n key) t ...)) () (() ()) () e bd ...))
    ((%alambda* "rey" () ((h ...) (i ...) (j ...) (jk ...))
                (r ...) (rk ...) () (() ()) () ((n t s ...) . e) bd ...)
     (%alambda* "rey" () ((h ...) (i ...) (j ... jm jn) (jk ... 'n))
                (r ...) (rk ... ((n 'n) t s ...)) () (() ()) () e bd ...))
    ((%alambda* "rey" () ((h ...) (i ...) (j ...) (jk ...))
                (r ...) (rk ...) () (() ()) () (n . e) bd ...)
     (%alambda* "rey" () ((h ...) (i ...) (j ... jm jn) (jk ... 'n))
                (r ...) (rk ... ((n 'n))) () (() ()) () e bd ...))
    ;; optional fix arguments
    ((%alambda* "opt" () hijk (r ...) (rk ...)
                (o ...) (() ()) () ((n d t ...) . e) bd ...)
     (%alambda* "opt" () hijk (r ...) (rk ...)
                (o ... (n d t ...)) (() ()) () e bd ...))
    ((%alambda* "opt" () hijk (r ...) (rk ...)
                (o ...) (() ()) () (n . e) bd ...)
     (%alambda* "opt" () hijk (r ...) (rk ...)
                (o ... (n #f)) (() ()) () e bd ...))
    ;; optional cat arguments
    ((%alambda* "cat" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ...)) (ok ...) ((n d t ...) . e) bd ...)
     (%alambda* "cat" () hijk (r ...) (rk ...) (o ...)
                ((c ... n) (k ...)) (ok ... ((n) d t ...)) e bd ...))
    ((%alambda* "cat" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ...)) (ok ...) (n . e) bd ...)
     (%alambda* "cat" () hijk (r ...) (rk ...) (o ...)
                ((c ... n) (k ...)) (ok ... ((n) #f)) e bd ...))
    ;; optional key arguments
    ((%alambda* "key" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ...)) (ok ...) (((n key) d t ...) . e) bd ...)
     (%alambda* "key" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ... key)) (ok ... ((n key) d t ...)) e bd ...))
    ((%alambda* "key" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ...)) (ok ...) (((n key)) . e) bd ...)
     (%alambda* "key" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ... key)) (ok ... ((n key) #f)) e bd ...))
    ((%alambda* "key" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ...)) (ok ...) ((n d t ...) . e) bd ...)
     (%alambda* "key" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ... 'n)) (ok ... ((n 'n) d t ...)) e bd ...))
    ((%alambda* "key" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ...)) (ok ...) (n . e) bd ...)
     (%alambda* "key" () hijk (r ...) (rk ...) (o ...)
                ((c ...) (k ... 'n)) (ok ... ((n 'n) #f)) e bd ...))
    ;; main
    ((%alambda* check () ((h ...) () () ()) ((n) ...) () () (()()) () () bd ...)
     (lambda (h ...) (let* ((n h) ...) bd ...)))
    ((%alambda* check () ((h ...) () () ()) ((n) ...) () () (()()) () e bd ...)
     (lambda (h ... . te) (let* ((n h) ... (e te)) bd ...)))
    ((%alambda* check dft ((h ...) (i ...) (j ...) jk)
                ((n t ...) ...) (((rn rk ...) rt ...) ...)
                () (() ()) () () bd ...)
     (lambda (h ... i ... j ...)
       (let ((zz (list i ... j ...)))
         (let* ((n (wow-opt n h t ...)) ...
                (rn (wow-req! zz dft jk (rn rk ...) rt ...)) ...)
           bd ...))))
    ((%alambda* check dft ((h ...) (i ...) (j ...) jk)
                ((n t ...) ...) (((rn rk ...) rt ...) ...)
                () (() ()) () e bd ...)
     (lambda (h ... i ... j ... . te)
       (let ((zz (list i ... j ...)))
         (let* ((n (wow-opt n h t ...)) ...
                (rn (wow-req! zz dft jk (rn rk ...) rt ...)) ...
                (e te))
           bd ...))))
    ((%alambda* check dft ((h ...) () () ()) ((n) ...) ()
                (o ...) ((c ...) (k ...)) (ondt ...) e bd ...)
     (lambda (h ... . te)
       (let* ((n h) ...)
         (check-opt* te dft (o ...) (ondt ...) e (k ...) bd ...))))
    ((%alambda* check dft ((h ...) (i ...) (j ...) jk)
                ((n t ...) ...) (((rn rk ...) rt ...) ...)
                (o ...) ((c ...) (k ...)) (ondt ...) e bd ...)
     (lambda (h ... i ... j ... . te)
       (let ((zz (list i ... j ...)))
         (let* ((n (wow-opt n h t ...)) ...
                (rn (wow-req! zz dft jk (rn rk ...) rt ...)) ...)
           (check-opt* te dft (o ...) (ondt ...) e (k ...) bd ...)))))))

(define-syntax check-cond
  (syntax-rules ()
    ((check-cond z len (tt ...) (nt ...) (((n t) . e) bd ...) cl ...)
     (check-cond z len (tt ... tn) (nt ... (n t)) (e bd ...) cl ...))
    ((check-cond z len (tt ...) (nt ...) ((n . e) bd ...) cl ...)
     (check-cond z len (tt ... tn) (nt ... (n)) (e bd ...) cl ...))
    ((check-cond z len () () (() bd ...) cl ...)
     (if (= len 0)
         ((lambda () bd ...))
         (check-cond z len () () cl ...)))
    ((check-cond z len () () (e bd ...) cl ...)
     (let ((e z)) bd ...))
    ((check-cond z len (tt ...) ((n) ...) (() bd ...) cl ...)
     (if (= len (length '(tt ...)))
         (apply (lambda (n ...) bd ...) z)
         (check-cond z len () () cl ...)))
    ((check-cond z len (tt ...) ((n t ...) ...) (() bd ...) cl ...)
     (if (and (= len (length '(tt ...)))
              (apply (lambda (tt ...) (cond-and ((n tt t ...) ...))) z))
         (apply (lambda (n ...) bd ...) z)
         (check-cond z len () () cl ...)))
    ((check-cond z len (tt ...) ((n) ...) (e bd ...) cl ...)
     (if (>= len (length '(tt ...)))
         (apply (lambda (n ... . e) bd ...) z)
         (check-cond z len () () cl ...)))
    ((check-cond z len (tt ...) ((n t ...) ...) (e bd ...) cl ...)
     (if (and (>= len (length '(tt ...)))
              (apply (lambda (tt ...) (cond-and ((n tt t ...) ...))) z))
         (apply (lambda (n ... . e) bd ...) z)
         (check-cond z len () () cl ...)))
    ((check-cond z len (tt ...) (nt ...))
     (error "actual arguments are not matched to any clause of alambda" z))))

(define-syntax check-cond*
  (syntax-rules ()
    ((check-cond* z len (tt ...) (nt ...) (((n t) . e) bd ...) cl ...)
     (check-cond* z len (tt ... tn) (nt ... (n t)) (e bd ...) cl ...))
    ((check-cond* z len (tt ...) (nt ...) ((n . e) bd ...) cl ...)
     (check-cond* z len (tt ... tn) (nt ... (n)) (e bd ...) cl ...))
    ((check-cond* z len () () (() bd ...) cl ...)
     (if (= len 0)
         ((lambda () bd ...))
         (check-cond* z len () () cl ...)))
    ((check-cond* z len () () (e bd ...) cl ...)
     (let ((e z)) bd ...))
    ((check-cond* z len (tt ...) ((n) ...) (() bd ...) cl ...)
     (if (= len (length '(tt ...)))
         (apply (lambda (tt ...) (let* ((n tt) ...) bd ...)) z)
         (check-cond* z len () () cl ...)))
    ((check-cond* z len (tt ...) ((n t ...) ...) (() bd ...) cl ...)
     (if (and (= len (length '(tt ...)))
              (apply (lambda (tt ...) (cond-and* ((n tt t ...) ...))) z))
         (apply (lambda (tt ...) (let* ((n tt) ...) bd ...)) z)
         (check-cond* z len () () cl ...)))
    ((check-cond* z len (tt ...) ((n) ...) (e bd ...) cl ...)
     (if (>= len (length '(tt ...)))
         (apply (lambda (tt ... . te) (let* ((n tt) ... (e te)) bd ...)) z)
         (check-cond* z len () () cl ...)))
    ((check-cond* z len (tt ...) ((n t ...) ...) (e bd ...) cl ...)
     (if (and (>= len (length '(tt ...)))
              (apply (lambda (tt ...) (cond-and* ((n tt t ...) ...))) z))
         (apply (lambda (tt ... . te) (let* ((n tt) ... (e te)) bd ...)) z)
         (check-cond* z len () () cl ...)))
    ((check-cond* z len (tt ...) (nt ...))
     (error "actual arguments are not matched to any clause of alambda*" z))))

(define-syntax cond-and
  (syntax-rules ()
    ((cond-and ((n v) nvt ...))
     (cond-and (nvt ...)))
    ((cond-and ((n v t) nvt ...))
     (and (let ((n v)) t) (cond-and (nvt ...))))
    ((cond-and ())
     #t)))

(define-syntax cond-and*
  (syntax-rules ()
    ((cond-and* ((n v) nvt ...))
     (let ((n v))
       (cond-and* (nvt ...))))
    ((cond-and* ((n v t) nvt ...))
     (let ((n v))
       (and t (cond-and* (nvt ...)))))
    ((cond-and* ())
     #t)))

(define-syntax check-opt
  (syntax-rules ()
    ((check-opt z dft (nd ...) ((n d t ...) ndt ...) (nodt ...)
                e (kk ...) bd ...)
     (let ((y (if (null? z) z (cdr z)))
           (x (if (null? z)
                  d
                  (wow-opt n (car z) t ...))))
       (check-opt y dft (nd ... (n x)) (ndt ...) (nodt ...)
                  e (kk ...) bd ...)))
    ((check-opt z dft (nd ...) () (((n k) d t ...) nodt ...)
                e (kk ...) bd ...)
     (let ((x (if (null? z)
                  d
                  (wow-key! z dft (kk ...) (n k) d t ...))))
       (check-opt z dft (nd ... (n x)) () (nodt ...) e (kk ...) bd ...)))
    ((check-opt z dft (nd ...) () (((n) d t ...) nodt ...) e (kk ...) bd ...)
     (let ((x (if (null? z)
                  d
                  (wow-cat! z n d t ...))))
       (check-opt z dft (nd ... (n x)) () (nodt ...) e (kk ...) bd ...)))
    ((check-opt z dft (nd ...) () () () (kk ...) bd ...)
     (if (null? z)
         (let (nd ...) bd ...)
         (error "alambda: too many arguments" z)))
    ((check-opt z dft (nd ...) () () e (kk ...) bd ...)
     (let (nd ... (e z)) bd ...))))

(define-syntax check-opt*
  (syntax-rules ()
    ((check-opt* z dft ((n d t ...) ndt ...) (nodt ...) e (kk ...) bd ...)
     (let ((y (if (null? z) z (cdr z)))
           (n (if (null? z)
                  d
                  (wow-opt n (car z) t ...))))
       (check-opt* y dft (ndt ...) (nodt ...) e (kk ...) bd ...)))
    ((check-opt* z dft () (((n k) d t ...) nodt ...) e (kk ...) bd ...)
     (let ((n (if (null? z)
                  d
                  (wow-key! z dft (kk ...) (n k) d t ...))))
       (check-opt* z dft () (nodt ...) e (kk ...) bd ...)))
    ((check-opt* z dft () (((n) d t ...) nodt ...) e (kk ...) bd ...)
     (let ((n (if (null? z)
                  d
                  (wow-cat! z n d t ...))))
       (check-opt* z dft () (nodt ...) e (kk ...) bd ...)))
    ((check-opt* z dft () () () (kk ...) bd ...)
     (if (null? z)
         (let () bd ...)
         (error "alambda*: too many arguments" z)))
    ((check-opt* z dft () () e (kk ...) bd ...)
     (let ((e z)) bd ...))))

(define-syntax wow-opt
  (syntax-rules ()
    ((wow-opt n v)
     v)
    ((wow-opt n v t)
     (let ((n v))
       (if t n (error "alambda[*]: bad argument" n 'n 't))))
    ((wow-opt n v t ts)
     (let ((n v))
       (if t ts (error "alambda[*]: bad argument" n 'n 't))))
    ((wow-opt n v t ts fs)
     (let ((n v))
       (if t ts fs)))))

(define-syntax wow-cat!
  (syntax-rules ()
    ((wow-cat! z n d)
     (let ((n (car z)))
       (set! z (cdr z))
       n))
    ((wow-cat! z n d t)
     (let ((n (car z)))
       (if t
           (begin (set! z (cdr z)) n)
           (let lp ((head (list n)) (tail (cdr z)))
             (if (null? tail)
                 d
                 (let ((n (car tail)))
                   (if t
                       (begin (set! z (append (reverse head) (cdr tail))) n)
                       (lp (cons n head) (cdr tail)))))))))
    ((wow-cat! z n d t ts)
     (let ((n (car z)))
       (if t
           (begin (set! z (cdr z)) ts)
           (let lp ((head (list n)) (tail (cdr z)))
             (if (null? tail)
                 d
                 (let ((n (car tail)))
                   (if t
                       (begin (set! z (append (reverse head) (cdr tail))) ts)
                       (lp (cons n head) (cdr tail)))))))))
    ((wow-cat! z n d t ts fs)
     (let ((n (car z)))
       (if t
           (begin (set! z (cdr z)) ts)
           (begin (set! z (cdr z)) fs))))))

(define-syntax wow-key!
  (syntax-rules ()
    ((wow-key! z () (kk ...) (n key) d)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (begin (set! z (cdr y)) (car y))
               (let lp ((head (list (car y) x)) (tail (cdr y)))
                 (if (null? tail)
                     d
                     (let ((x (car tail))
                           (y (cdr tail)))
                       (if (null? y)
                           d
                           (if (equal? key x)
                               (begin (set! z (append (reverse head) (cdr y)))
                                      (car y))
                               (lp (cons (car y) (cons x head))
                                   (cdr y)))))))))))
    ((wow-key! z (#f) (kk ...) (n key) d)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (begin (set! z (cdr y)) (car y))
               (let ((lk (list kk ...)))
                 (if (not (member x lk))
                     d
                     (let lp ((head (list (car y) x)) (tail (cdr y)))
                       (if (null? tail)
                           d
                           (let ((x (car tail))
                                 (y (cdr tail)))
                             (if (null? y)
                                 d
                                 (if (equal? key x)
                                     (begin (set! z (append (reverse head)
                                                            (cdr y)))
                                            (car y))
                                     (if (not (member x lk))
                                         d
                                         (lp (cons (car y) (cons x head))
                                             (cdr y))))))))))))))
    ((wow-key! z (#t) (kk ...) (n key) d)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (begin (set! z (cdr y)) (car y))
               (let* ((lk (list kk ...))
                      (m (member x lk)))
                 (let lp ((head (if m (list (car y) x) (list x)))
                          (tail (if m (cdr y) y)))
                   (if (null? tail)
                       d
                       (let ((x (car tail))
                             (y (cdr tail)))
                         (if (null? y)
                             d
                             (if (equal? key x)
                                 (begin (set! z (append (reverse head)
                                                        (cdr y)))
                                        (car y))
                                 (let ((m (member x lk)))
                                   (lp (if m
                                           (cons (car y) (cons x head))
                                           (cons x head))
                                       (if m (cdr y) y)))))))))))))
    ((wow-key! z () (kk ...) (n key) d t)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) n)
                     (error "alambda[*]: bad argument" n 'n 't)))
               (let lp ((head (list (car y) x)) (tail (cdr y)))
                 (if (null? tail)
                     d
                     (let ((x (car tail))
                           (y (cdr tail)))
                       (if (null? y)
                           d
                           (if (equal? key x)
                               (let ((n (car y)))
                                 (if t
                                     (begin (set! z (append (reverse head)
                                                            (cdr y)))
                                            n)
                                     (error "alambda[*]: bad argument"
                                            n 'n 't)))
                               (lp (cons (car y) (cons x head))
                                   (cdr y)))))))))))
    ((wow-key! z (#f) (kk ...) (n key) d t)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) n)
                     (error "alambda[*]: bad argument" n 'n 't)))
               (let ((lk (list kk ...)))
                 (if (not (member x lk))
                     d
                     (let lp ((head (list (car y) x)) (tail (cdr y)))
                       (if (null? tail)
                           d
                           (let ((x (car tail))
                                 (y (cdr tail)))
                             (if (null? y)
                                 d
                                 (if (equal? key x)
                                     (let ((n (car y)))
                                       (if t
                                           (begin
                                             (set! z (append (reverse head)
                                                             (cdr y)))
                                             n)
                                           (error "alambda[*]: bad argument"
                                                  n 'n 't)))
                                     (if (not (member x lk))
                                         d
                                         (lp (cons (car y) (cons x head))
                                             (cdr y))))))))))))))
    ((wow-key! z (#t) (kk ...) (n key) d t)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) n)
                     (error "alambda[*]: bad argument" n 'n 't)))
               (let* ((lk (list kk ...))
                      (m (member x lk)))
                 (let lp ((head (if m (list (car y) x) (list x)))
                          (tail (if m (cdr y) y)))
                   (if (null? tail)
                       d
                       (let ((x (car tail))
                             (y (cdr tail)))
                         (if (null? y)
                             d
                             (if (equal? key x)
                                 (let ((n (car y)))
                                   (if t
                                       (begin (set! z (append (reverse head)
                                                              (cdr y)))
                                              n)
                                       (error "alambda[*]: bad argument"
                                              n 'n 't)))
                                 (let ((m (member x lk)))
                                   (lp (if m
                                           (cons (car y) (cons x head))
                                           (cons x head))
                                       (if m (cdr y) y)))))))))))))
    ((wow-key! z () (kk ...) (n key) d t ts)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) ts)
                     (error "alambda[*]: bad argument" n 'n 't)))
               (let lp ((head (list (car y) x)) (tail (cdr y)))
                 (if (null? tail)
                     d
                     (let ((x (car tail))
                           (y (cdr tail)))
                       (if (null? y)
                           d
                           (if (equal? key x)
                               (let ((n (car y)))
                                 (if t
                                     (begin (set! z (append (reverse head)
                                                            (cdr y)))
                                            ts)
                                     (error "alambda[*]: bad argument"
                                            n 'n 't)))
                               (lp (cons (car y) (cons x head))
                                   (cdr y)))))))))))
    ((wow-key! z (#f) (kk ...) (n key) d t ts)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) ts)
                     (error "alambda[*]: bad argument" n 'n 't)))
               (let ((lk (list kk ...)))
                 (if (not (member x lk))
                     d
                     (let lp ((head (list (car y) x)) (tail (cdr y)))
                       (if (null? tail)
                           d
                           (let ((x (car tail))
                                 (y (cdr tail)))
                             (if (null? y)
                                 d
                                 (if (equal? key x)
                                     (let ((n (car y)))
                                       (if t
                                           (begin
                                             (set! z (append (reverse head)
                                                             (cdr y)))
                                             ts)
                                           (error "alambda[*]: bad argument"
                                                  n 'n 't)))
                                     (if (not (member x lk))
                                         d
                                         (lp (cons (car y) (cons x head))
                                             (cdr y))))))))))))))
    ((wow-key! z (#t) (kk ...) (n key) d t ts)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) ts)
                     (error "alambda[*]: bad argument" n 'n 't)))
               (let* ((lk (list kk ...))
                      (m (member x lk)))
                 (let lp ((head (if m (list (car y) x) (list x)))
                          (tail (if m (cdr y) y)))
                   (if (null? tail)
                       d
                       (let ((x (car tail))
                             (y (cdr tail)))
                         (if (null? y)
                             d
                             (if (equal? key x)
                                 (let ((n (car y)))
                                   (if t
                                       (begin (set! z (append (reverse head)
                                                              (cdr y)))
                                              ts)
                                       (error "alambda[*]: bad argument"
                                              n 'n 't)))
                                 (let ((m (member x lk)))
                                   (lp (if m
                                           (cons (car y) (cons x head))
                                           (cons x head))
                                       (if m (cdr y) y)))))))))))))
    ((wow-key! z () (kk ...) (n key) d t ts fs)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) ts)
                     (begin (set! z (cdr y)) fs)))
               (let lp ((head (list (car y) x)) (tail (cdr y)))
                 (if (null? tail)
                     d
                     (let ((x (car tail))
                           (y (cdr tail)))
                       (if (null? y)
                           d
                           (if (equal? key x)
                               (let ((n (car y)))
                                 (if t
                                     (begin (set! z (append (reverse head)
                                                            (cdr y)))
                                            ts)
                                     (begin (set! z (append (reverse head)
                                                            (cdr y)))
                                            fs)))
                               (lp (cons (car y) (cons x head))
                                   (cdr y)))))))))))
    ((wow-key! z (#f) (kk ...) (n key) d t ts fs)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) ts)
                     (begin (set! z (cdr y)) fs)))
               (let ((lk (list kk ...)))
                 (if (not (member x lk))
                     d
                     (let lp ((head (list (car y) x)) (tail (cdr y)))
                       (if (null? tail)
                           d
                           (let ((x (car tail))
                                 (y (cdr tail)))
                             (if (null? y)
                                 d
                                 (if (equal? key x)
                                     (let ((n (car y)))
                                       (if t
                                           (begin
                                             (set! z (append (reverse head)
                                                             (cdr y)))
                                             ts)
                                           (begin
                                             (set! z (append (reverse head)
                                                             (cdr y)))
                                             fs)))
                                     (if (not (member x lk))
                                         d
                                         (lp (cons (car y) (cons x head))
                                             (cdr y))))))))))))))
    ((wow-key! z (#t) (kk ...) (n key) d t ts fs)
     (let ((x (car z))
           (y (cdr z)))
       (if (null? y)
           d
           (if (equal? key x)
               (let ((n (car y)))
                 (if t
                     (begin (set! z (cdr y)) ts)
                     (begin (set! z (cdr y)) fs)))
               (let* ((lk (list kk ...))
                      (m (member x lk)))
                 (let lp ((head (if m (list (car y) x) (list x)))
                          (tail (if m (cdr y) y)))
                   (if (null? tail)
                       d
                       (let ((x (car tail))
                             (y (cdr tail)))
                         (if (null? y)
                             d
                             (if (equal? key x)
                                 (let ((n (car y)))
                                   (if t
                                       (begin (set! z (append (reverse head)
                                                              (cdr y)))
                                              ts)
                                       (begin (set! z (append (reverse head)
                                                              (cdr y)))
                                              fs)))
                                 (let ((m (member x lk)))
                                   (lp (if m
                                           (cons (car y) (cons x head))
                                           (cons x head))
                                       (if m (cdr y) y)))))))))))))))

(define-syntax wow-req!
  (syntax-rules ()
    ((wow-req! z (ft ...) (kk ...) (n))
     (let ((n (car z)))
       (set! z (cdr z)) n))
    ((wow-req! z () (kk ...) (n key))
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (begin (set! z (cdr y)) (car y))
           (let lp ((head (list (car y) x)) (tail (cdr y)))
             (if (null? tail)
                 (error "alambda[*]: no corresponding value to key"
                        key (reverse head))
                 (let ((x (car tail))
                       (y (cdr tail)))
                   (if (null? y)
                       (error "alambda[*]: no corresponding value to key"
                              key (append (reverse head) tail))
                       (if (equal? key x)
                           (begin (set! z (append (reverse head) (cdr y)))
                                  (car y))
                           (lp (cons (car y) (cons x head)) (cdr y))))))))))
    ((wow-req! z (#f) (kk ...) (n key))
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (begin (set! z (cdr y)) (car y))
           (let ((lk (list kk ...)))
             (if (not (member x lk))
                 (error "alambda[*]: no keyword" x lk)
                 (let lp ((head (list (car y) x)) (tail (cdr y)))
                   (if (null? tail)
                       (error "alambda[*]: no corresponding value to key"
                              key (reverse head))
                       (let ((x (car tail))
                             (y (cdr tail)))
                         (if (null? y)
                             (error "alambda[*]: no corresponding value to key"
                                    key (append (reverse head) tail))
                             (if (equal? key x)
                                 (begin
                                   (set! z (append (reverse head) (cdr y)))
                                   (car y))
                                 (if (not (member x lk))
                                     (error "alambda[*]: no keyword" x lk)
                                     (lp (cons (car y) (cons x head))
                                         (cdr y)))))))))))))
    ((wow-req! z (#t) (kk ...) (n key))
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (begin (set! z (cdr y)) (car y))
           (let* ((lk (list kk ...))
                  (m (member x lk)))
             (let lp ((head (if m (list (car y) x) (list x)))
                      (tail (if m (cdr y) y)))
               (if (null? tail)
                   (error "alambda[*]: no corresponding value to key"
                          key (reverse head))
                   (let ((x (car tail))
                         (y (cdr tail)))
                     (if (null? y)
                         (error "alambda[*]: no corresponding value to key"
                                key (append (reverse head) tail))
                         (if (equal? key x)
                             (begin (set! z (append (reverse head) (cdr y)))
                                    (car y))
                             (let ((m (member x lk)))
                               (lp (if m
                                       (cons (car y) (cons x head))
                                       (cons x head))
                                   (if m (cdr y) y))))))))))))
    ((wow-req! z (ft ...) (kk ...) (n) t)
     (let ((n (car z)))
       (if t
           (begin (set! z (cdr z)) n)
           (let lp ((head (list n)) (tail (cdr z)))
             (if (null? tail)
                 (error "alambda[*]: bad arguments" (reverse head) 'n 't)
                 (let ((n (car tail)))
                   (if t
                       (begin (set! z (append (reverse head) (cdr tail))) n)
                       (lp (cons n head) (cdr tail)))))))))
    ((wow-req! z () (kk ...) (n key) t)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) n)
                 (error "alambda[*]: bad argument" n 'n 't)))
           (let lp ((head (list (car y) x)) (tail (cdr y)))
             (if (null? tail)
                 (error "alambda[*]: no corresponding value to key"
                        key (reverse head))
                 (let ((x (car tail))
                       (y (cdr tail)))
                   (if (null? y)
                       (error "alambda[*]: no corresponding value to key"
                              key (append (reverse head) tail))
                       (if (equal? key x)
                           (let ((n (car y)))
                             (if t
                                 (begin (set! z (append (reverse head)
                                                        (cdr y)))
                                        n)
                                 (error "alambda[*]: bad argument" n 'n 't)))
                           (lp (cons (car y) (cons x head)) (cdr y))))))))))
    ((wow-req! z (#f) (kk ...) (n key) t)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) n)
                 (error "alambda[*]: bad argument" n 'n 't)))
           (let ((lk (list kk ...)))
             (if (not (member x lk))
                 (error "alambda[*]: no keyword" x lk)
                 (let lp ((head (list (car y) x)) (tail (cdr y)))
                   (if (null? tail)
                       (error "alambda[*]: no corresponding value to key"
                              key (reverse head))
                       (let ((x (car tail))
                             (y (cdr tail)))
                         (if (null? y)
                             (error "alambda[*]: no corresponding value to key"
                                    key (append (reverse head) tail))
                             (if (equal? key x)
                                 (let ((n (car y)))
                                   (if t
                                       (begin (set! z (append (reverse head)
                                                              (cdr y)))
                                              n)
                                       (error "alambda[*]: bad argument"
                                              n 'n 't)))
                                 (if (not (member x lk))
                                     (error "alambda[*]: no keyword" x lk)
                                     (lp (cons (car y) (cons x head))
                                         (cdr y)))))))))))))
    ((wow-req! z (#t) (kk ...) (n key) t)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) n)
                 (error "alambda[*]: bad argument" n 'n 't)))
           (let* ((lk (list kk ...))
                  (m (member x lk)))
             (let lp ((head (if m (list (car y) x) (list x)))
                      (tail (if m (cdr y) y)))
               (if (null? tail)
                   (error "alambda[*]: no corresponding value to key"
                          key (reverse head))
                   (let ((x (car tail))
                         (y (cdr tail)))
                     (if (null? y)
                         (error "alambda[*]: no corresponding value to key"
                                key (append (reverse head) tail))
                         (if (equal? key x)
                             (let ((n (car y)))
                               (if t
                                   (begin (set! z (append (reverse head)
                                                          (cdr y)))
                                          n)
                                   (error "alambda[*]: bad argument"
                                          n 'n 't)))
                             (let ((m (member x lk)))
                               (lp (if m
                                       (cons (car y) (cons x head))
                                       (cons x head))
                                   (if m (cdr y) y))))))))))))
    ((wow-req! z (ft ...) (kk ...) (n) t ts)
     (let ((n (car z)))
       (if t
           (begin (set! z (cdr z)) ts)
           (let lp ((head (list n)) (tail (cdr z)))
             (if (null? tail)
                 (error "alambda[*]: bad arguments" (reverse head) 'n 't)
                 (let ((n (car tail)))
                   (if t
                       (begin (set! z (append (reverse head) (cdr tail))) ts)
                       (lp (cons n head) (cdr tail)))))))))
    ((wow-req! z () (kk ...) (n key) t ts)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) ts)
                 (error "alambda[*]: bad argument" n 'n 't)))
           (let lp ((head (list (car y) x)) (tail (cdr y)))
             (if (null? tail)
                 (error "alambda[*]: no corresponding value to key"
                        key (reverse head))
                 (let ((x (car tail))
                       (y (cdr tail)))
                   (if (null? y)
                       (error "alambda[*]: no corresponding value to key"
                              key (append (reverse head) tail))
                       (if (equal? key x)
                           (let ((n (car y)))
                             (if t
                                 (begin (set! z (append (reverse head)
                                                        (cdr y)))
                                        ts)
                                 (error "alambda[*]: bad argument" n 'n 't)))
                           (lp (cons (car y) (cons x head)) (cdr y))))))))))
    ((wow-req! z (#f) (kk ...) (n key) t ts)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) ts)
                 (error "alambda[*]: bad argument" n 'n 't)))
           (let ((lk (list kk ...)))
             (if (not (member x lk))
                 (error "alambda[*]: no keyword" x lk)
                 (let lp ((head (list (car y) x)) (tail (cdr y)))
                   (if (null? tail)
                       (error "alambda[*]: no corresponding value to key"
                              key (reverse head))
                       (let ((x (car tail))
                             (y (cdr tail)))
                         (if (null? y)
                             (error "alambda[*]: no corresponding value to key"
                                    key (append (reverse head) tail))
                             (if (equal? key x)
                                 (let ((n (car y)))
                                   (if t
                                       (begin (set! z (append (reverse head)
                                                              (cdr y)))
                                              ts)
                                       (error "alambda[*]: bad argument"
                                              n 'n 't)))
                                 (if (not (member x lk))
                                     (error "alambda[*]: no keyword" x lk)
                                     (lp (cons (car y) (cons x head))
                                         (cdr y)))))))))))))
    ((wow-req! z (#t) (kk ...) (n key) t ts)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) ts)
                 (error "alambda[*]: bad argument" n 'n 't)))
           (let* ((lk (list kk ...))
                  (m (member x lk)))
             (let lp ((head (if m (list (car y) x) (list x)))
                      (tail (if m (cdr y) y)))
               (if (null? tail)
                   (error "alambda[*]: no corresponding value to key"
                          key (reverse head))
                   (let ((x (car tail))
                         (y (cdr tail)))
                     (if (null? y)
                         (error "alambda[*]: no corresponding value to key"
                                key (append (reverse head) tail))
                         (if (equal? key x)
                             (let ((n (car y)))
                               (if t
                                   (begin (set! z (append (reverse head)
                                                          (cdr y)))
                                          ts)
                                   (error "alambda[*]: bad argument"
                                          n 'n 't)))
                             (let ((m (member x lk)))
                               (lp (if m
                                       (cons (car y) (cons x head))
                                       (cons x head))
                                   (if m (cdr y) y))))))))))))
    ((wow-req! z (ft ...) (kk ...) (n) t ts fs)
     (let ((n (car z)))
       (if t
           (begin (set! z (cdr z)) ts)
           (begin (set! z (cdr z)) fs))))
    ((wow-req! z () (kk ...) (n key) t ts fs)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) ts)
                 (begin (set! z (cdr y)) fs)))
           (let lp ((head (list (car y) x)) (tail (cdr y)))
             (if (null? tail)
                 (error "alambda[*]: no corresponding value to key"
                        key (reverse head))
                 (let ((x (car tail))
                       (y (cdr tail)))
                   (if (null? y)
                       (error "alambda[*]: no corresponding value to key"
                              key (append (reverse head) tail))
                       (if (equal? key x)
                           (let ((n (car y)))
                             (if t
                                 (begin (set! z (append (reverse head)
                                                        (cdr y)))
                                        ts)
                                 (begin (set! z (append (reverse head)
                                                        (cdr y)))
                                        fs)))
                           (lp (cons (car y) (cons x head)) (cdr y))))))))))
    ((wow-req! z (#f) (kk ...) (n key) t ts fs)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) ts)
                 (begin (set! z (cdr y)) fs)))
           (let ((lk (list kk ...)))
             (if (not (member x lk))
                 (error "alambda[*]: no keyword" x lk)
                 (let lp ((head (list (car y) x)) (tail (cdr y)))
                   (if (null? tail)
                       (error "alambda[*]: no corresponding value to key"
                              key (reverse head))
                       (let ((x (car tail))
                             (y (cdr tail)))
                         (if (null? y)
                             (error "alambda[*]: no corresponding value to key"
                                    key (append (reverse head) tail))
                             (if (equal? key x)
                                 (let ((n (car y)))
                                   (if t
                                       (begin (set! z (append (reverse head)
                                                              (cdr y)))
                                              ts)
                                       (begin (set! z (append (reverse head)
                                                              (cdr y)))
                                              fs)))
                                 (if (not (member x lk))
                                     (error "alambda[*]: no keyword" x lk)
                                     (lp (cons (car y) (cons x head))
                                         (cdr y)))))))))))))
    ((wow-req! z (#t) (kk ...) (n key) t ts fs)
     (let ((x (car z))
           (y (cdr z)))
       (if (equal? key x)
           (let ((n (car y)))
             (if t
                 (begin (set! z (cdr y)) ts)
                 (begin (set! z (cdr y)) fs)))
           (let* ((lk (list kk ...))
                  (m (member x lk)))
             (let lp ((head (if m (list (car y) x) (list x)))
                      (tail (if m (cdr y) y)))
               (if (null? tail)
                   (error "alambda[*]: no corresponding value to key"
                          key (reverse head))
                   (let ((x (car tail))
                         (y (cdr tail)))
                     (if (null? y)
                         (error "alambda[*]: no corresponding value to key"
                                key (append (reverse head) tail))
                         (if (equal? key x)
                             (let ((n (car y)))
                               (if t
                                   (begin (set! z (append (reverse head)
                                                          (cdr y)))
                                          ts)
                                   (begin (set! z (append (reverse head)
                                                          (cdr y)))
                                          fs)))
                             (let ((m (member x lk)))
                               (lp (if m
                                       (cons (car y) (cons x head))
                                       (cons x head))
                                   (if m (cdr y) y))))))))))))))
